
<!DOCTYPE html>
<!--Estine van der Berg
    26 May 2020 -->

    <html lang="en">
    <head>
        <meta charset = "utf-8">
        <title> Blog </title>
        <!--stylesheet-->
        <link rel="stylesheet" type = "text/css" href="stylesheet.css">
        <!--icons-->
        <script src="https://kit.fontawesome.com/7a3b930300.js" crossorigin="anonymous"></script>
    </head>

    <body>
        <!-- Nav Bar-->
        <ul class="nav">

            <!-- Logo -->
            <div class="logo">
                <a href = "index.html" rel = "import">ESTINEVDB</a>
            </div>
            <!-- End Logo-->
            <li><div class="dropdown">
                <button class="dropbtn">ARTICLE LIST</button>
                <div class="dropdown-content">
                  <a href="#blogHeader">Concurrency in Java</a>
                  <a href="#blogContainer">Inheritance in Java</a>
                </div>
              </div>
              </li>
            <li><a href = "#blogContainer">LATEST ARTICLE</a></li>
            <li><a href = "#Contact">CONTACT</a></li>
        </ul>
        <!--End Nav Bar-->

        <!--Banner-->
        <div class ="banner">
            <img class="banner-image" src = "banner2.jpg" alt = "Banner_Image">
            <div class="banner-header2">
                <h1>EstineVDB</h1>
                <h2>BLOG</h2>
            </div>
        </div>
        <!--End Banner-->

        <!--Blog-->
        <div class = "blog">
            <!--Blog Header-->
            <div id = "blogHeader" class = "blogHeader">
                <h1>CONCURRENCY IN JAVA</h1>
                <img class = "underlineImg" src = "Feathers.png" alt = "Image">
                <p class = "bodyPar" >Concurrency is being able to do more than one thing at the same time, without affecting the final outcome. 
                    In modern programming it is everywhere. Graphical User Interfaces (GUI) do work in the background that does not interrupt the user, 
                    applications are processing on servers and websites are handeling a lot of different users. You are probably streaming audio right now while reading this blog. That is concurrency.
                </p>
                <p class = "bodyPar">Concurrent Software is software that does more than one thing at a time, it doesn't use multiple processors. In fact it's possible to run multiple tasks on a single processer. How is this done?
                    The tasks don't execute at the same time, instead the system switches between the tasks. This happens so frequently that it seems like everything is happening at once. 
                    So the multiple tasks are each making progress during the same time frame. Concurrency allows us to reduce the execution time of a data-intensive problems. 
                </p>
            </div>
            <!--End of Blog Header-->

            <!--Blog Body-->
            <div class = "blogBody">
                <!--First Section-->
                <div class = "processThreads">
                    <h1 class = "bodyheading">Process And Threads</h1>
                    <p class = "bodyPar">Processes and Threads are the two basic units of concurrency.
                        The difference between them is that a process is a program loaded into memory with all of the resources it needs to run and a thread is the unit of execution within a process. 
                        A Process has a self-contained execution environment and generally has a complete, private set of basic run-time resources such as memory space. 
                        Threads exist within a process, and every process has at least one thread. The thread sharing the process' resources makes for efficient communication.
                    <br>
                        A computer system normally has many active processes and threads. Each instance of a running program is a process. There can be multiple instances of a single program.
                        This is true even in systems that only have a single execution core, and thus only have one thread actually executing at any given moment. 
                        Each process runs independently from other processes because they have an independent memory address space.
                    </p>
                </div>
                <!--End of First Section-->

                <!--Second Section-->
                <div class = "RunningThreads">

                    <h1 class = "bodyheading">Starting And Running A Thread In Java</h1>

                    <p class = "bodyPar">Java provides built in support for multithreading. Multithreading is when two or more threads are executed at the same time. 
                    <br>
                        It can become complex when multiple threads need to access the same resources. Multiple threads modifying a single shared resource can lead to unpredictable behaviour. 
                        Multiple threads are still necessary for things like running the User Interface(UI) while simultaneously monitoring message queues.
                        A Java Thread is a lightweight process.
                    </p>   
                    <p class = "bodyPar">To Create a thread in java follow these steps:</p>

                    <!--Code Section-->

                    <p class = "bodyPar">
                        <div class = "codeblock">
                            <pre>
                                <code> //Create a Worker class that extends Thread 
                                        public class Worker extends Thread {
                                    
                                        @Override  //
                                        public void run() { // Overridden the run() method
                                            
                                            // Loop for ten iterations.
                                            for(int i=0; i&lt;10; i++) {
                                                System.out.println("Running...");
                                                
                                                // Sleep for a while
                                                try {
                                                    Thread.sleep(200);
                                                } catch (InterruptedException e) {
                                                    // Interrupted exception will occur if the Worker object's interrupt() method
                                                    // is called. interrupt() is inherited from the Thread class.
                                                    break;
                                                }
                                            }
                                        }
                                    
                                    }
                                    
                                </code> 
                            </pre>
                        </div>
                    </p>
                    <!--End of Code Section-->
                    <p class = "bodyPar">
                        If you use <code>sleep()</code>, you have to catch the InterruptedException. This is thrown if a thread is interrupted while its sleeping. To interrupt a thread, call its <code>interrupt()</code> method. 
                        By calling break if the thread is interrupted, the execution of any surrounding loop will stop.
                        When two Worker classes are created and their inherited <code>start()</code> methods are called, they both run at the same time, they run concurrently. 
                    </p>
                </div>
                <!--End of Second Section-->

                <!--Third Section-->
                <div class = "thirdSection">

                    <h1 class = "bodyheading">Different States Of A Thread</h1>
                    <p class = "bodyPar">There are various states of a thread: <code>New</code>, <code>Runnable</code>, <code>Waiting</code> , <code>Blocked</code>, <code>Timed Waiting</code> and <code>Terminated</code>.
                    <br>
                    <code>New</code>:
                        As soon as a new thread is created, it's in the <code>New</code> state. The thread is not alive yet.
                    <br>
                    <code>Runnable</code>:
                        The thread is put into a running state as soon as <code>start()</code> is called.
                    <br>
                    <code>Waiting</code> :
                        A running thread can be suspended to temporarily stop its activity. 
                        It will pick up where it left off and return to the <code>Runnable</code> state when it is allowed to resume. 
                    <br>
                    <code>Blocked</code>:
                        A thread can get <code>Blocked</code> when it tries to access code that is currently locked by another thread. 
                        The person scheduling the code is responsible for determining when threads run.
                    <br>
                    <code>Timed Waiting</code>:
                        A <code>Runnable</code> thread can change to <code>Timed Waiting</code> if it is provided with an optional waiting time. 
                        When it's waiting for another thread to perform a task, it will go into timed waiting and wait for the other thread to notify it when it's done or resume its task once the time has lapsed.
                    <br>
                    <code>Terminated</code>:
                        A thread can be terminated in two ways. It exits normally after the program has completed its code execution, or when there are unhandled errors. 
                        When terminated, execution is halted immediately and once a thread is terminated, it cannot be resumed. 
                    </p>
                </div>
                <!--End of Third Section-->

                <!--Fourth Section-->
                <div class = "daemon">
                    <h1 class = "bodyheading">Daemon Thread</h1>
                    <p class = "bodyPar">Daemon thread in Java is a service provider thread that provides services to the user thread for background supporting tasks.
                        The Daemon thread is dependent on the user threads. When all the user threads complete their execution, Java Virtual Machine (JVM) terminates itself.
                        The JVM does not care whether Daemon threads are running or not and only waits for user threads to finish.
                    </p>
                    
                    <p class = "bodyPar">Here is a list of when you may want to use a daemon thread:
                    </p>

                    <p>
                    <div class = "list">
                        <ul>
                            <li>Collection of statistics and status monitoring task</li>
                            <li>Performing asynchronous I/O tasks</li>
                            <li>Listening for incoming connections</li>
                            <li>Garbage collection</li>
                            <li>Releasing memory of unused objects</li>
                            <li>Removing unwanted entries from the cache</li>
                        </ul>
                    </div>
                    </p>

                    <p class = "bodyPar">To create a Daemon thread in Java follow these steps:
                    </p>

                    
                    <div class = "codeblock">
                        <pre>
                            <code>
                                package com.myjava.threads;
                                
                                public class DaemonThread extends Thread{
                                    
                                    //To specify that a thread is a daemon thread, 
                                    //call the setDaemon method with the argument true.

                                    public DaemonThread(){
                                        setDaemon(true); 
                                    }
                                    public void run(){

                                        //To determine if a thread is a daemon thread, 
                                        //use the accessor method isDaemon

                                        System.out.println("Is this thread Daemon? - "+isDaemon()); 
                                    }
                                    public static void main(String a[]){
                                        DaemonThread dt = new DaemonThread();
                                        // You can also set the Daemon Constraing here : dt.setDeamon(true)
                                        dt.start();
                                    }
                                }
                            </code>
                        </pre>
                    </div>
                
                </div>
                <!--End of Fourth Section-->

                <!--Fifth Section-->
                <div class ="jmm">
                    <h1 class = "bodyheading">Java Memory Model (JMM)</h1>
                    <p class = "bodyPar">The JMM stipulates how the Java virtual machine (JVM) works with the computer's memory (RAM).
                        The JVM is a model of a whole computer, this model includes a memory model, as in: the Java Memory Model.
                    <br>
                        The JMM describes how threads in Java interact through memory. Including the description of single threaded execution of code, 
                        the JMM provides the semantics of the Java Programming Language.
                    </p>
                </div>
                <!--End of Fifth Section-->

                <!--Fifth Section-->
                <div class = "fifth">
                    <h1 class = "bodyheading">Deadlock, Livelock and Starvation</h1>
                    <p class = "bodyPar">
                        Deadlock is when there are two or more threads that are blocked forever because they are waiting for each other to exit the task.
                    <br>
                    <br>
                        Livelock is when two or more threads change their state continuously, and they clash with each other's state, they fail to progress because both of them are 
                        changing state, they are too busy responding to each other to resume work.
                    <br>
                    <br>
                        Starvation is when a thread cannot gain access to shared resources and is unable to make progress beacuse of this. 
                        This happens when shared resources are unavailable for long periods of time due to another thread monopolizing the resource.
                    </p>
                </div>
                <!--End of Fifth Section-->

                <!--Sixth Section-->
                <div class = "overriding">
                    <h1 class = "bodyheading">Overriding Thread Class <code>run()</code> Method</h1>
                    <p class = "bodyPar" >What happens if you don’t override the thread class <code>run()</code> method?
                    <br>
                        It is highly recommended to override <code>run()</code> method because it improves the performance of the system. 
                        When we call the <code>start()</code> method on thread, it internally calls the <code>run()</code> method with a newly created thread. 
                        So, if we don’t override the <code>run()</code> method, the newly created thread won’t be called and there will be no output.
                    </p>
                </div>
                <!--End of Sixth Section-->

                <!--Seventh Section-->
                <div class = "atomic">
                    <h1 class = "bodyheading">Atomic Operations And Atomic Classes</h1>
                    <p class = "bodyPar">Atomic operations are performed in a single unit of task without interference from other operations, they run completely independently of any other processes.
                        Atomic operations are a necessity in multi-threaded environments to avoid data inconsistency, and are used in many modern operating systems.
                        <br>
                        The java.util.concurrent.atomic package defines classes that support atomic operations on single variables. 
                        All classes have get and set methods that work like reads and writes on volatile variables. A set has a happens-before relationship with any subsequent get on the same variable. 
                        The atomic compareAndSet method also has these memory consistency features, as do the simple atomic arithmetic methods that apply to integer atomic variables. 

                    </p>
                </div>
                 <!--End of Seventh Section-->

                <!--Eighth Section-->
                <div class = "Executor">
                    <h1 class = "bodyheading">Executor And ExecutorService</h1>
                    <p class = "bodyPar">Executor is the core interface which is an abstraction for parallel execution. It separates task from execution.
                    <br>
                        ExecutorService is an extension of Executor interface and provides a facility for returning a Future object and terminate, or shut down the thread pool. 
                        Once the shutdown is called, the thread pool will not accept new tasks, but will complete any pending task.
                    <br>
                    <br>
                        The differences between Executor and ExecutorService is that Executor is a parent interface while ExecutorService is a sub-interface of Executor and extends it.
                        Executor uses the <code>execute()</code> method for submitting tasks, while the ExecutorService uses the <code>submit()</code> method. 
                    <br>
                        The <code>execute()</code> method accepts an object of the Runnable interface, while <code>submit()</code>  method can accept objects of both Runnable and Callable interfaces.
                        The <code>execute()</code> method doesn't return any result, its return type is void but the <code>submit()</code>  method returns the result of a computation via a Future object. 
                        This is also the key difference between <code>submit()</code> and <code>execute()</code> method, which is one of the frequently asked Java concurrency interview questions.
                        With Executor, you cannot cancel the task once completed, whereas with ExecutorService, you can cancel the task by using <code>Future.cancel()</code>.
                        Executor doesn't provide any method for shutdown, but ExecutorService provides methods for shutdown of the pool
                    </p>
                </div>
                    <!--End of Eighth Section-->

                <!--Nineth Section-->
                <div class = "concurrent">
                    <h1 class = "bodyheading">Concurrent Classes</h1>
                    <p class = "bodyPar">The Concurrent Collection APIs, apart from the Java Collection API, are a set of collections APIs that are designed and optimized specifically for synchronized multithreaded access.
                        They are grouped under the java.util.concurrent package.
                    <br>
                        The concurrent collection classes are highly scalable and low risk. The concurrent collection APIs of Java provide a range of classes that are specifically designed to deal with concurrent 
                        operations. These classes are alternatives to the Java Collection Framework and provide similar functionality except with the additional support of concurrency.
                    <br>
                    <br>
                        The classes in the new concurrent collection framework include: 
                        <ul>
                            <li>ArrayBlockingQueue</li>
                            <li>ConcurrentLinkedDeque</li>
                            <li>ConcurrentLinkedQueue</li>
                            <li>ConcurrentSkipListMap</li>
                            <li>CopyOnWriteArraySet</li>
                            <li>LinkedBlockingDeque</li>
                            <li>DelayQueue</li>
                            <li>LinkedBlockingQueue</li>
                            <li>SynchronousQueue</li>
                            <li>LinkedTransferQueue</li>
                            <li>PriorityBlockingQueue</li>

                        </ul>
                    </p>
                </div>
                <!--End of Nineth Section-->
                <!--End Section-->
                <div class = "endSection">
                    <img class = "bottomImg" src = "banner-end.png" alt = "banner-img">
                    
                    <p class = "concl">This post was an assignment research project.
                    <br>
                        For more information on Concurrency in Java, visit the <a href = "https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html">JavaDocs</a> 
                    </p>
                </div>
                <!--End of End Section-->
            </div>
            <!--End of Blog Body-->
        </div>
        <!--End of BlogConcurrency-->

        <!--BlogInterface Start-->
        <div id = "blogContainer" class = "blogInterface">
            <img class = "banner" src = "interface.jpg" alt = "Banner_Image">

            <!--Blog2 Header-->
                <div  class = "blog2heading">
                    <h1>JAVA INTERFACES</h1>
                    <img src = "flowers.png" alt = "image">
                </div>

                <!--Blog2 Body-->
                <!--Part one-->
                <div class = "interface">
                    <h1>What is an interface in Java?</h1>
                    <p>
                        An Interface is a datatype and it is similar to a class. However, unlike classes, it can only contain constants, method signatures, default methods, static methods, and nested types.
                        Interfaces cannot be instantiated—they can only be implemented by classes or extended by other interfaces. When a class implements an interface, it implements all the methods defined in 
                        the interface with the exact signature and return type. A class can also implement more than one interface.
                    <br>
                        Implementing an interface allows a class to become more formal about the behavior it promises to provide. 
                        It's a description of duties that a class is obliged to do.
                        Interfaces form a contract between the class and the outside world, and this contract is enforced at build time by the compiler. 
                        If your class claims to implement an interface, all methods defined by that interface must appear in its source code before the class will successfully compile.
                    <br>
                    </p>
                </div>
                <!--End Part one-->

                <!--Part Two-->
                <div class = "whyinterface">
                    <h1>Why do we use interface?</h1>
                        <p>Interface are key of API design. In fact smaller interfaces like Comparable, Runnable, and Callable makes core of Java API.
                            <br>
                            Interface allows multiple inheritance in Java.
                            <br>
                            Interfaces are a way to declare a contract for implementing classes to fulfil; it's the primary tool to create abstraction 
                            <br>
                            Use of interface allows you to supply a new implementation, which could be more robust, which will allow more performance in later stages of your development.
                            <br>
                            A code written on interface is much more flexible than the one which is written on implementation.
                            <br>
                            It is important for disparate groups of programmers to agree to a "contract" that spells out how their software interacts. 
                            <br>
                            Each group should be able to write their code without any knowledge of how the other group's code is written.
                    </p>
                </div>      
                <!--End Part Two-->     

                <!--Part Three-->
                <div class = "absVSint">
                    <h1> What are the differences between an abstract class and an interface? </h1>
                        <p>
                            <br>
                            An abstract class can have instance methods that implements a default behavior.
                            <br>
                            A Java class can implement multiple interfaces but it can extend only one abstract class. 
                            <br>
                            Interfaces are slow in comparison with java abstract classes, as interfaces requires extra indirection.
                            <br>
                            Variables declared in a Java interface is by default final. An  abstract class may contain non-final variables
                            <br>
                            One of the main differences is that the methods of an interface are completely abstract and cannot have implementations.
                            <br>
                            Members of a Java interface are public by default. A Java abstract class can have class members like private, protected, etc..
                            <br>
                            Interface is absolutely abstract and cannot be instantiated; A Java abstract class also cannot be instantiated, but can be invoked if a <code>main()</code> exists.
                        </p>
                </div>
                <!--End Part Three--> 

                <!--Part Four-->
                <div class = "abstract">
                    <h1>Why is abstraction an important concept in software development and what role do interfaces play in abstraction?</h1>
                    <p>
                        Abstraction is one of the key concepts of object-oriented programming (OOP) languages. It's the process of taking away or removing characteristics from something in order to reduce it to a set of essential characteristics 
                        The programmer hides all but the relevant data about an object in order to reduce complexity and increase efficiency
                        Abstraction is one of the key elements of good software design. It helps encapsulate behavior, decouple software elements and it helps having more self-contained modules amongst other things. It also helps programmers build more
                        complex code. Abstraction makes the application easily extendable and it makes refactoring much easier.
                    <br>
                    <br>
                        You can define an interface when you need to guide the programmer or make a contract specifying how the methods and fields of a type should be.
                        You would need to implement this interface in order to create an abstract object, you also need to provide a body for all the abstract methods of the interface and obtain the object of the implementing class.
                        The user who is using the interface methods, only knows the classes that implement this interface and their methods, information about the implementation is completely hidden from the user, thus achieving abstraction.
                    </p>
                </div>
                <!--End Part Four-->

                <!--Part Five-->
                <div class = "interfaceImplement">
                    <h1>What must a class do in order to implement an interface?</h1>
                    <p>
                    To declare a class that implements an interface, you include an implements clause in the class declaration.
                    Your class can implement more than one interface, so the implements keyword is followed by a comma-separated list of the interfaces implemented by the class. 
                    The implements clause follows the extends clause, if there is one.
                    </p>
                </div>
                <!--End Part Five-->

                <!--Part Six-->
                <div class = "abstractMethod">
                    <h1>What is an abstract method?</h1>
                    <p>An abstract class is a class that is declared abstract—it may or may not include abstract methods. Abstract classes cannot be instantiated, but they can be subclassed.
                    <br>
                    An Abstract method is a method without a body, meaning there is no implementation. If a class has an abstract method, the class itself should be declared abstract as well.
                    </p>
                </div>
                <!--End Part Six-->
                
                <!--Part Seven-->
                <div class = "instantiate">
                    <h1>Can you instantiate an interface?</h1>
                    <p>
                        Can you instantiate an interface in Java? 
                        Not being able to instantiate something means that you cannot create the object of an interface.
                        The answer is no.
                    <br>
                        It would defy the Object Oriented Model. There would be no purpose to instantiate is as 'nothing' will happen.
                        Some of their methods might not have any definitions
                    </p>
                </div>
                <!--End Part Seven-->
                
                <!--Part Eight-->
                <div class = "constructor">
                    <h1>Can you declare a constructor inside an interface?</h1>
                        <p>
                        Can you declare a constructor inside an interface?
                        No, interface cannot have constructors.
                        <br>
                        There would be no point in having a constructor in an interface as interface cannot be instantiated. All the methods you define in an interface should be implemented by another class 
                        (overridden). 
                        But, you cannot override constructors in Java.
                        </p>
                </div>
                <!--End Part Eight-->
                
                <!--Part Nine-->
                <div class = "override">
                    <h1>Can we override an interface method with visibility that is not public?</h1>
                    <p>
                    When you try and override an interface method with weaker access (private or default) then you will raise an compilation error.
                    The methods of an interface must be public. If it is not specified, the default will be public. 
                    Therefore when the subclass which implements the interface overrides, it can only use the same specifier or a stronger one. 
                    No stronger specifier than public exists in Java. For this, reason, all the methods of interface must be overridden with public only.
                    </p>
                </div>
                <!--End Part Nine-->
                <!--End Section-->
                <div class = "endSection2">
                    <img class = "bottomImg" src = "banner-end2.1.png" alt = "banner-img">
                    
                    <p class = "ending">This post was an assignment research project.
                    <br>
                        For more information on Interfaces in Java, visit the <a href = "https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html">JavaDocs</a> 
                    </p>
                </div>
                <!--End of End Section-->
            </div>
            <!--End Blog Container-->



        <!--Contact-Footer-->
        <div id = "Contact" class="heading">CONTACT</div>
        <div class = "footer">
             
            <!--Inner Footer-->
            <div class = "inner_footer">
                <h1>ESTINE VAN DER BERG</h1>
                <h2>EMAIL: estine.cook@gmail.com</h2>
            </div>
            <!--End of Inner Footer-->
            <!--Third Footer-->
            <div class = "footer_third">
                <a href="https://www.linkedin.com/in/estinevdb/"><i class="fab fa-linkedin"></i></a> <!--Using images links from font awesome as links to websites-->
                <a href="https://github.com/c00ke"><i class="fab fa-github"></i></a>
                <a href="https://www.instagram.com/estinevdb/"><i class="fab fa-instagram"></i></a>
                <a href="https://www.youtube.com/channel/UCWOsdGYJ0A3nPphvIaNcC4g/about?view_as=subscriber"><i class="fab fa-youtube"></i></a>
            </div>
            <!--End of Third Footer-->
        </div>
        <!--End Contact-footer-->
        <!--Copyright-->
        <div class = "copyright">
            <p>Copyright &copy; 2020, Estine van der Berg, All Rights Reserved</p>
        </div>
        <!--End of Copyright-->


    </body>
    </html>
